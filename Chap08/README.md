<!-- omit in toc -->

> # Chapter 08. 범용 컬렉션
>
> - 러스트의 표준 라이브러리는 여러 종류의 컬렉션을 포함하고 있으며, 이는 매우 유용한 데이터 구조이다.
> - 내장된 배열과 튜플은 힙 메모리에 저장되며, 데이터의 크기를 컴파일 시점에 알 필요가 없다.
> - 이는, 런타임에서 크기를 변경할 수 있다는 뜻이다.
> - 각 컬렉션은 수용량과 처리 비용이 다르므로, 독자가 스스로 개발해야 할 기술이 되겠다.
> - 이번 장에서는 **벡터**, **문자열**, **해시 맵** 컬렉션을 살펴본다.

<details>
<summary>Table of Contents</summary>

- [8-1 벡터에 일련의 값 저장하기](#8-1-벡터에-일련의-값-저장하기)
  - [새로운 벡터 생성하기](#새로운-벡터-생성하기)
  - [벡터 수정](#벡터-수정)
  - [벡터 해제](#벡터-해제)
  - [벡터로부터 값 읽기](#벡터로부터-값-읽기)
  - [벡터에 저장된 값을 순회하기](#벡터에-저장된-값을-순회하기)
  - [열거자를 이용해 여러 타입 저장하기](#열거자를-이용해-여러-타입-저장하기)
- [8-2 String 타입에 UTF-8 형식의 텍스트 저장하기](#8-2-string-타입에-utf-8-형식의-텍스트-저장하기)
  - [문자열이란 무엇일까?](#문자열이란-무엇일까)
  - [새 문자열 생성하기](#새-문자열-생성하기)
  - [문자열 수정하기](#문자열-수정하기)
    - [(1) `push_str`과 `push` 메서드를 이용해 문자열 덧붙이기](#1-push_str과-push-메서드를-이용해-문자열-덧붙이기)
    - [(2) `+` 연산자나 `format!` 매크로를 이용한 문자열 연결](#2--연산자나-format-매크로를-이용한-문자열-연결)
  - [문자열의 인덱스](#문자열의-인덱스)
    - [(1) 문자열의 내부](#1-문자열의-내부)

</details>

---

# 8-1 벡터에 일련의 값 저장하기

- 벡터를 이용하면 하나 이상의 값을 하나의 데이터 구조에 담을 수 있다.

## 새로운 벡터 생성하기

- 새로운 빈 벡터를 생성하려면 아래와 같이 `Vec::new` 함수를 호출하면 된다.

```
let v: Vec<i32> = Vew::new()
```

- 벡터에는 아직 값을 저장하지 않았으므로, 어떤 값이 저장될지 미리 알 수 없기 때문에 타입에 대한 애노테이션을 사용한다.
- 또한, 벡터가 제네릭을 이용해 구현되었기 때문이다.
- 아래는 1, 2, 3 값을 저장하는 `Vec<i32>` 타입의 벡터를 생성하는 코드이다.

```
let v = vec![1, 2, 3];
```

## 벡터 수정

- 벡터를 생성하고 값을 추가하려면 아래와 같이 `push` 메서드를 사용한다.
- `push` 메서드에 전달한 값은 모두 `i32` 타입이며, 데이터로부터 값을 유추하므로 `Vec<i32>`와 같이 타입 애노테이션을 사용할 필요가 없다.

```
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

## 벡터 해제

- 벡터가 메모리에서 해제되면 벡터에 저장된 모든 값도 해제된다.

```
{
  let v = vec![1, 2, 3, 4];
}
```

## 벡터로부터 값 읽기

- 아래는 인덱스 문법(indexing syntax)과 `get` 메서드를 각각 설명하고 있다.

```
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("Third element : {}", third);

match v.get(2) {
  Some(third) => println!("Third element : {}", third),
  None => println!("No such element"),
}
```

- 첫 번째 방법은 `&`와 `[]`를 이용하여 저장된 값에 대한 참조를 리턴한다.
- 두 번째 방법은 `get` 메서드를 이용하여 `Option<&T>` 타입의 값을 리턴한다.
- 러스트에서 벡터에 저장된 값을 참조하는 방법은 두 가지이므로, 벡터에 존재하지 않는 인덱스 값을 사용할 때 프로그램이 어떻게 반응할 것인지를 직접 결정할 수 있다.
- 아래는 다섯 개의 값을 저장한 벡터에서 100번째 인덱스 값을 읽는 예시이다.

```
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

- 위 코드의 `[]` 방식은 패닉(panic)이 발생한다.
- 반면, `get` 메서드를 통한 방법은 `None` 값이 리턴된다.
- 이때는 벡터로부터 값을 읽은 후, 이 값이 `Some(&element)`인지 `None`인지 판단하면 된다.
- 프로그램이 유효한 참조값을 얻게 되면 벡터에 저장된 값에 대한 참조가 계속해서 유효할 수 있도록 대여값 검사가 실행되어 소유권과 대여 규칙을 적용한다.
- 아래는 불변 참조를 가지면서 벡터에 새로운 값을 추가하므로 코드가 의도대로 동작하지 않는다.

```
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0];

v.push(6);
```

- 위 코드는 벡터에 새로운 값을 추가하기 위해 새로운 메모리를 할당하고 이미 저장된 값들을 새로운 메모리 공간으로 옮겨야 할 수도 있기 때문에, **`first` 변수에 저장된 참조는 메모리로부터 해제되며** 대여 규칙상 프로그램은 이런 상황으로부터 보호되어야 하므로 오류가 발생한다.

## 벡터에 저장된 값을 순회하기

- 아래는 벡터를 순회(iterate)하는 예시이다.

```
let v = vec![1, 2, 3, 4, 5];
for i in &v {
  println!("{}", i);
}
```

- 또한, 가변 벡터에 저장된 값의 가변 참조를 얻어와 값을 변경할 수도 있다.

```
let mut v = vec![1, 2, 3, 4, 5];
for i in &mut v {
  *i += 50;
}
```

- 가변 참조가 가리키는 값을 변경하려면 `+=` 연산자를 사용하기 전에 역참조 연산자(`*`)를 이용해 변수 `i`에 저장된 값을 가져와야 한다.

## 열거자를 이용해 여러 타입 저장하기

- 열거자의 열것값은 같은 열거자 타입으로 평가되므로 벡터에 다른 타입의 값을 저장하려면 열거자를 정의해 사용하면 된다.

```
enum SpreadsheetCell {
  Int(i32),
  Float(f64),
  Text(String),
}

let row = vec![
  SpreadsheetCell::Int(3),
  SpreadsheetCell::Text(String::from("test")),
  SpreadsheetCell::Float(10.12),
]
```

- 러스트는 컴파일 시점에 벡터에 어떤 값이 저장될지 알아야 하므로 어느 정도의 힙 메모리가 필요한지도 정확히 판단한다.
- 열거자와 `match` 표현식을 조합하면 러스트가 컴파일 시점에 모든 경우의 수에 대한 처리를 보장해준다.

---

# 8-2 String 타입에 UTF-8 형식의 텍스트 저장하기

## 문자열이란 무엇일까?

- `String` 타입은 언어의 명세에 정의된 것이 아니라 러스트의 표준 라이브러리가 제공하는 타입니다.
- 러스트의 표준 라이브러리는 `OsString`, `OsStr`, `CString`, `CStr`과 같은 다른 종류의 문자열 타입도 제공한다.

## 새 문자열 생성하기

- `String` 타입은 `Vec<T>` 타입이 지원하는 대부분 작업을 지원한다.
- 따라서 아래처럼 `new` 함수를 이용해 새 문자열을 생성할 수 있다.

```
let mut s = String::new();
```

- 문자열을 생성할 때 초깃값을 지정할 수도 있다.
- 문자열 리터럴처럼 `Display` 크레이트를 구현한 모든 타입에서 사용할 수 있는 `to_string` 메서드를 활용하면 된다.

```
let data = "First value";
let s = data.to_string();
```

## 문자열 수정하기

- `+` 연산자나 `format!` 매크로를 이용해 문자열을 손쉽게 연결할 수 있다.

### (1) `push_str`과 `push` 메서드를 이용해 문자열 덧붙이기

```
let mut s = String::from("foo");
s.push_str("bar");
```

- 위 코드를 실행하면 변수 `s`에는 'foobar'라는 문자열이 저장된다.
- `push_str` 메서드가 문자열 슬라이스를 이용하는 이유는 매개변수의 소유권을 가질 필요가 없기 때문이다.
- 아래의 코드는 변수 `s2`의 데이터를 변수 `s1`에 덧붙이고 난 후에도 변수 `s2`를 계속해서 사용할 수 있음을 보여준다.

```
let mut s1 = String::from("foo");
let s2 = "bar";

s1.push_bar(s2);
println!("s2: {}", s2);
```

- 위 예제는 만일 `push_str` 메서드가 변수 `s2`에 대한 소유권을 갖게 된다면 마지막 줄에서 변숫값을 출력할 수 없게 된다.
- `push` 메서드는 하나의 문자를 매개변수로 전달받아 `String`에 추가한다.

```
let s = String::from("lo");
s.push('l');
```

### (2) `+` 연산자나 `format!` 매크로를 이용한 문자열 연결

```
let s1 = String::from("first, ");
let s2 = String::from("second.");

let s3 = s1 + &s2;
```

- 위 코드를 실행하면 변수 `s3`에는 "first, second."라는 값이 저장된다.
- 이때 변수 `s1`은 더 이상 사용할 수 없게 되는 이유와 변수 `s2`는 값이 아닌 참조를 전달한 이유는 `+` 연산자를 사용하면 내부적으로 호출되는 메서드의 시그너처 때문이다.
- `+` 연산자는 `add` 메서드는 이 메서드는 다음과 같이 선언되어 있다.

```
fn add(self, s: &str) -> String {
```

- 아래와 같이 `format!` 매크로를 이용할 수 있다.

```
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{}-{}-{}", s1, s2, s3);
```

## 문자열의 인덱스

- 러스트에서는 인덱스를 이용해 `String` 값의 일부에 접근하려 하면 에러가 발생한다.

```
let s1 = String::from("hello");
let h = s1[0];
```

```
[E0277] Error: the type `String` cannot be indexed by `{integer}`
   ╭─[command_5:1:1]
   │
 2 │ let h = s1[0];
   │         ──┬──
   │           ╰──── `String` cannot be indexed by `{integer}`
───╯
```

### (1) 문자열의 내부

- `String`은 `Vec<u8>` 타입을 한 번 감싼 타입이다.

```
let len = String::from("Hola").len();
```

- 이 경우 변수 `len`의 값은 `4`가 된다.
- 단, 유니코드 스칼라값은 3byte 공간을 차지하므로, 한글로 구성된 문자열은 정상적으로 동작하지 않는다.
