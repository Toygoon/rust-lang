<!-- omit in toc -->

> # Chapter 08. 범용 컬렉션
>
> - 러스트의 표준 라이브러리는 여러 종류의 컬렉션을 포함하고 있으며, 이는 매우 유용한 데이터 구조이다.
> - 내장된 배열과 튜플은 힙 메모리에 저장되며, 데이터의 크기를 컴파일 시점에 알 필요가 없다.
> - 이는, 런타임에서 크기를 변경할 수 있다는 뜻이다.
> - 각 컬렉션은 수용량과 처리 비용이 다르므로, 독자가 스스로 개발해야 할 기술이 되겠다.
> - 이번 장에서는 **벡터**, **문자열**, **해시 맵** 컬렉션을 살펴본다.

<details>
<summary>Table of Contents</summary>

- [8-1 벡터에 일련의 값 저장하기](#8-1-벡터에-일련의-값-저장하기)
  - [새로운 벡터 생성하기](#새로운-벡터-생성하기)
  - [벡터 수정](#벡터-수정)
  - [벡터 해제](#벡터-해제)
  - [벡터로부터 값 읽기](#벡터로부터-값-읽기)
  - [벡터에 저장된 값을 순회하기](#벡터에-저장된-값을-순회하기)
  - [열거자를 이용해 여러 타입 저장하기](#열거자를-이용해-여러-타입-저장하기)

</details>

---

# 8-1 벡터에 일련의 값 저장하기

- 벡터를 이용하면 하나 이상의 값을 하나의 데이터 구조에 담을 수 있다.

## 새로운 벡터 생성하기

- 새로운 빈 벡터를 생성하려면 아래와 같이 `Vec::new` 함수를 호출하면 된다.

```
let v: Vec<i32> = Vew::new()
```

- 벡터에는 아직 값을 저장하지 않았으므로, 어떤 값이 저장될지 미리 알 수 없기 때문에 타입에 대한 애노테이션을 사용한다.
- 또한, 벡터가 제네릭을 이용해 구현되었기 때문이다.
- 아래는 1, 2, 3 값을 저장하는 `Vec<i32>` 타입의 벡터를 생성하는 코드이다.

```
let v = vec![1, 2, 3];
```

## 벡터 수정

- 벡터를 생성하고 값을 추가하려면 아래와 같이 `push` 메서드를 사용한다.
- `push` 메서드에 전달한 값은 모두 `i32` 타입이며, 데이터로부터 값을 유추하므로 `Vec<i32>`와 같이 타입 애노테이션을 사용할 필요가 없다.

```
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

## 벡터 해제

- 벡터가 메모리에서 해제되면 벡터에 저장된 모든 값도 해제된다.

```
{
  let v = vec![1, 2, 3, 4];
}
```

## 벡터로부터 값 읽기

- 아래는 인덱스 문법(indexing syntax)과 `get` 메서드를 각각 설명하고 있다.

```
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("Third element : {}", third);

match v.get(2) {
  Some(third) => println!("Third element : {}", third),
  None => println!("No such element"),
}
```

- 첫 번째 방법은 `&`와 `[]`를 이용하여 저장된 값에 대한 참조를 리턴한다.
- 두 번째 방법은 `get` 메서드를 이용하여 `Option<&T>` 타입의 값을 리턴한다.
- 러스트에서 벡터에 저장된 값을 참조하는 방법은 두 가지이므로, 벡터에 존재하지 않는 인덱스 값을 사용할 때 프로그램이 어떻게 반응할 것인지를 직접 결정할 수 있다.
- 아래는 다섯 개의 값을 저장한 벡터에서 100번째 인덱스 값을 읽는 예시이다.

```
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

- 위 코드의 `[]` 방식은 패닉(panic)이 발생한다.
- 반면, `get` 메서드를 통한 방법은 `None` 값이 리턴된다.
- 이때는 벡터로부터 값을 읽은 후, 이 값이 `Some(&element)`인지 `None`인지 판단하면 된다.
- 프로그램이 유효한 참조값을 얻게 되면 벡터에 저장된 값에 대한 참조가 계속해서 유효할 수 있도록 대여값 검사가 실행되어 소유권과 대여 규칙을 적용한다.
- 아래는 불변 참조를 가지면서 벡터에 새로운 값을 추가하므로 코드가 의도대로 동작하지 않는다.

```
let mut v = vec![1, 2, 3, 4, 5];
let first = &v[0];

v.push(6);
```

- 위 코드는 벡터에 새로운 값을 추가하기 위해 새로운 메모리를 할당하고 이미 저장된 값들을 새로운 메모리 공간으로 옮겨야 할 수도 있기 때문에, **`first` 변수에 저장된 참조는 메모리로부터 해제되며** 대여 규칙상 프로그램은 이런 상황으로부터 보호되어야 하므로 오류가 발생한다.

## 벡터에 저장된 값을 순회하기

- 아래는 벡터를 순회(iterate)하는 예시이다.

```
let v = vec![1, 2, 3, 4, 5];
for i in &v {
  println!("{}", i);
}
```

- 또한, 가변 벡터에 저장된 값의 가변 참조를 얻어와 값을 변경할 수도 있다.

```
let mut v = vec![1, 2, 3, 4, 5];
for i in &mut v {
  *i += 50;
}
```

- 가변 참조가 가리키는 값을 변경하려면 `+=` 연산자를 사용하기 전에 역참조 연산자(`*`)를 이용해 변수 `i`에 저장된 값을 가져와야 한다.

## 열거자를 이용해 여러 타입 저장하기

- 열거자의 열것값은 같은 열거자 타입으로 평가되므로 벡터에 다른 타입의 값을 저장하려면 열거자를 정의해 사용하면 된다.

```
enum SpreadsheetCell {
  Int(i32),
  Float(f64),
  Text(String),
}

let row = vec![
  SpreadsheetCell::Int(3),
  SpreadsheetCell::Text(String::from("test")),
  SpreadsheetCell::Float(10.12),
]
```

- 러스트는 컴파일 시점에 벡터에 어떤 값이 저장될지 알아야 하므로 어느 정도의 힙 메모리가 필요한지도 정확히 판단한다.
- 열거자와 `match` 표현식을 조합하면 러스트가 컴파일 시점에 모든 경우의 수에 대한 처리를 보장해준다.
