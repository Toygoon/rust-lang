# Chapter 04. 소유권

- 소유권은 러스트의 독특한 기능 중 하나로, `Garbage Collector`에 의존하지 않고도 메모리 안정성을 보장하려는 러스트만의 해법이다.
- 이번 장에서는 소유권과 더불이 `borrowing`, `slice`, 메모리 관리 방법을 살펴본다.

<details>
<summary>Table of Contents</summary>

- [4-1 소유권이란?](#4-1-소유권이란?)

</details>

---

# 4-1 소유권이란?

- 소유권은 러스트의 핵심 기능이다.
- Java는 가비지 콜렉터를 사용해 사용하지 않는 메모리를 지속적으로 찾아 자동으로 해제한다.
- C 계열 언어는 프로그래머가 명시적으로 메모리를 할당하고 해제해 주어야 한다.
- 러스트는 제3의 방법을 사용한다.
- 메모리는 컴파일러가 컴파일 시점에 검사하는 다양한 규칙으로 이루어진 소유권 시스템에 의해 관리된다.
- 따라서 소유권과 관련된 기능은 프로그램의 실행 성능에 아무런 영향을 미치지 않는다.

### 스택 메모리와 힙 메모리

- 러스트 같은 시스템 프로그래밍 언어 환경에서는 값이 스택 메모리에 저장되었는지 힙 메모리에 저장되었는지에 따라 언어의 동작이나 의사결정에 큰 영향을 미친다.
- 스택에 데이터를 푸시하는 것이 힙에 할당하는 것보다 빠른 이유는 OS가 새 데이터를 저장할 공간을 찾을 필요가 없기 때문이다.
- 새 데이터는 항상 스택의 가장 위에 추가된다.
- 힙에 공간을 할당하는 것은 상대적으로 더 많은 작업이 필요하다.
- OS가 데이터를 저장할 충분히 큰 공간을 찾은 후 다음 할당 작업을 위한 예약 작업을 수행해야 하는 이유다.
- 코드에서 함수를 호출할 때 함수에는 여러 값이 전달되며, 이 값들은 함수의 로컬 변수에 할당되어 스택에 저장된다.
- 함수의 실행이 완료되면 이 값들은 스택에서 제거된다.

## 소유권 규칙

- 러스트가 다루는 각각의 값은 소유자(owner)라고 부르는 변수를 가지고 있다.
- 특정 시점에 값의 소유자는 단 하나뿐이다.
- 소유자가 범위를 벗어나면 그 값은 제거된다.

## 변수의 범위

- 변수의 범위(scope)에 대해 확인해보자.
- 다음과 같이 변수를 하나 선언했다고 생각해보자.

```
let s = "hello";
```

- 변수 `s`는 프로그램 안에 하드코딩한 문자열값인 문자열 리터럴을 참조한다.
- 변수 `s`는 선언된 지점부터 현재 범위를 벗어나기 전까지 유효하다.
- 변수는 범위 안으로 들어오면 유효하고, 범위를 벗어나기 전까지 유효하다.

## String 타입

- 문자열 리터럴은 텍스트를 다루어야 하는 모든 경우에 적잡한 방법은 아니다.
- 그 이유 중 하나는 문자열이 `immutable` 특성을 가지기 때문이다.
- 러스트는 또 다른 타입인 `String` 타입을 제공한다.
- 이 타입은 힙에 할당되므로 컴파일 시점에 알 수 없는 크기의 문자열을 저장할 수 있다.
- 다음과 같이 `from` 함수를 이용하면 문자열 리터럴을 이용해 `String` 인스턴스를 생성할 수 있다.

```
let s = String::from("hello");
```

- 이렇게 생성한 문자열은 변경이 가능하다.

```
let mut s = String::from("hello");
s.push_str(", world");

println!("{}", s);
```

## 메모리와 할당
